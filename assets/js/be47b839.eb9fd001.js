"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[14956],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>c});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=l(n),c=o,m=h["".concat(u,".").concat(c)]||h[c]||d[c]||a;return n?r.createElement(m,i(i({ref:t},p),{},{components:n})):r.createElement(m,i({ref:t},p))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},40596:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>u,default:()=>f,frontMatter:()=>s,metadata:()=>l,toc:()=>d});n(67294);var r=n(3905);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}const s={title:"React Router v6"},u=void 0,l={unversionedId:"routing/integrations/react-router/index",id:"routing/integrations/react-router/index",title:"React Router v6",description:"Refine provides a simple interface from the routerProvider prop to infer the resource from route, pass, parse and sync the query parameters and handle navigation operations. This provider and its properties are optional but recommended to get the most out of Refine.",source:"@site/docs/routing/integrations/react-router/index.md",sourceDirName:"routing/integrations/react-router",slug:"/routing/integrations/react-router/",permalink:"/ithub-itday-april-refine/docs/routing/integrations/react-router/",draft:!1,editUrl:"https://github.com/refinedev/refine/tree/master/documentation/docs/routing/integrations/react-router/index.md",tags:[],version:"current",frontMatter:{title:"React Router v6"},sidebar:"mainSidebar",previous:{title:"useApiUrl",permalink:"/ithub-itday-april-refine/docs/data/hooks/use-api-url/"},next:{title:"useResource",permalink:"/ithub-itday-april-refine/docs/routing/hooks/use-resource/"}},p={},d=[{value:"Usage",id:"usage",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Usage with Authentication",id:"usage-with-authentication",level:3},{value:"Usage with Layouts",id:"usage-with-layouts",level:3},{value:"Usage with Access Control providers",id:"usage-with-access-control-providers",level:3},{value:"Usage with an Error Page",id:"usage-with-an-error-page",level:3},{value:"Usage with a Root Route",id:"usage-with-a-root-route",level:3},{value:"Additional Components",id:"additional-components",level:2},{value:"NavigateToResource",id:"navigatetoresource",level:3},{value:"Properties",id:"properties",level:4},{value:"UnsavedChangesNotifier",id:"unsavedchangesnotifier",level:3},{value:"Properties",id:"properties-1",level:4},{value:"CatchAllNavigate",id:"catchallnavigate",level:3},{value:"Properties",id:"properties-2",level:4},{value:"DocumentTitleHandler",id:"documenttitlehandler",level:3},{value:"Properties",id:"properties-3",level:4},{value:"Hooks",id:"hooks",level:2},{value:"useDocumentTitle",id:"usedocumenttitle",level:3},{value:"FAQ",id:"faq",level:2},{value:"How to handle optional authentication, redirects and layouts with authentication?",id:"how-to-handle-optional-authentication-redirects-and-layouts-with-authentication",level:3},{value:"Handling 404s",id:"handling-404s",level:3},{value:"404 Pages for both authenticated and not authenticated users",id:"404-pages-for-both-authenticated-and-not-authenticated-users",level:4},{value:"404 Pages for authenticated users only",id:"404-pages-for-authenticated-users-only",level:4}],h=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)},c=h("InstallPackagesCommand"),m=h("CreateRefineAppCommand"),g={toc:d};function f(e){var{components:t}=e,n=i(e,["components"]);return(0,r.kt)("wrapper",a(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},r=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),r.forEach((function(t){o(e,t,n[t])}))}return e}({},g,n),{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Refine provides a simple interface from the ",(0,r.kt)("inlineCode",{parentName:"p"},"routerProvider")," prop to infer the resource from route, pass, parse and sync the query parameters and handle navigation operations. This provider and its properties are optional but recommended to get the most out of Refine."),(0,r.kt)("p",null,"Refine provides router bindings and utilities for ",(0,r.kt)("a",{parentName:"p",href:"https://reactrouter.com/"},"React Router v6"),". It is built on top of the ",(0,r.kt)("inlineCode",{parentName:"p"},"react-router-dom")," package. This package will provide easy integration between Refine and ",(0,r.kt)("strong",{parentName:"p"},"react-router-dom")," for both existing projects and new projects."),(0,r.kt)(c,{args:"@refinedev/react-router-v6 react-router-dom",mdxType:"InstallPackagesCommand"}),(0,r.kt)("p",null,"We recommend using ",(0,r.kt)("inlineCode",{parentName:"p"},"create refine-app")," to initialize your Refine projects. It gives you a good boilerplate to start with using React Router v6."),(0,r.kt)(m,{args:"-p refine-react my-refine-app",mdxType:"CreateRefineAppCommand"}),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/react-router-v6")," is not restricting you to use the router in a specific way and it is up to you to decide how you want to use it."),(0,r.kt)("p",null,"You can define your routes the way you want, then pass the ",(0,r.kt)("inlineCode",{parentName:"p"},"routerProvider")," prop to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Refine")," component and use the ",(0,r.kt)("inlineCode",{parentName:"p"},"resources")," prop to define the resources and their action paths. From basic to advanced use cases and enterprise applications, you will have full control over your routes. In our examples, we've used this approach to demonstrate the flexibility of the router provider and the route handling process."),(0,r.kt)("h3",{id:"basic-usage"},"Basic Usage"),(0,r.kt)("p",null,"We'll pass the ",(0,r.kt)("inlineCode",{parentName:"p"},"routerProvider")," prop to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Refine")," component to instruct Refine on how to communicate with the router. We'll also define our resources and their action paths, this will inform Refine to use these paths when generating the breadcrumbs, menus, handling redirections and inferring the current resource and action."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"title=App.jsx",title:"App.jsx"},'import { Refine } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\n// highlight-start\nimport routerProvider from "@refinedev/react-router-v6";\nimport { BrowserRouter, Routes, Route } from "react-router-dom";\n// highlight-end\n\nimport { PostList, PostCreate } from "pages/posts";\nimport { CategoryList, CategoryShow } from "pages/categories";\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Refine\n        dataProvider={dataProvider}\n        // highlight-next-line\n        routerProvider={routerProvider}\n        resources={[\n          {\n            name: "posts",\n            // highlight-start\n            list: "/posts",\n            create: "/posts/create",\n            // highlight-end\n          },\n          {\n            name: "categories",\n            // highlight-start\n            list: "/categories",\n            show: "/categories/show/:id",\n            // highlight-end\n          },\n        ]}\n      >\n        <Routes>\n          {/* highlight-start */}\n          <Route path="posts">\n            <Route index element={<PostList />} />\n            <Route path="create" element={<PostCreate />} />\n          </Route>\n          <Route path="categories">\n            <Route index element={<CategoryList />} />\n            <Route path="show/:id" element={<CategoryShow />} />\n          </Route>\n          {/* highlight-end */}\n        </Routes>\n      </Refine>\n    </BrowserRouter>\n  );\n};\n')),(0,r.kt)("h3",{id:"usage-with-authentication"},"Usage with Authentication"),(0,r.kt)("p",null,"When handling authenticated routes, we can use ",(0,r.kt)("a",{parentName:"p",href:"/docs/authentication/components/authenticated"},(0,r.kt)("inlineCode",{parentName:"a"},"<Authenticated>"))," to check if the user is authenticated or not. Internally, it uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"useIsAuthenticated")," hook and handles the redirection or showing the appropriate elements based on the authentication status by the ",(0,r.kt)("inlineCode",{parentName:"p"},"children")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"fallback")," props."),(0,r.kt)("p",null,"Additionally, we'll use the ",(0,r.kt)("a",{parentName:"p",href:"https://reactrouter.com/en/main/components/outlet"},(0,r.kt)("inlineCode",{parentName:"a"},"<Outlet>"))," component from ",(0,r.kt)("inlineCode",{parentName:"p"},"react-router-dom")," to render our routes inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Authenticated>")," component. This will allow us to create protected routes and render the routes only when the user is authenticated."),(0,r.kt)("p",null,"We will also need to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," route to handle the redirection when the user is not authenticated. We can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthPage")," components from Refine's UI packages with ",(0,r.kt)("inlineCode",{parentName:"p"},'type="login"')," prop to render the login page."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"title=App.jsx",title:"App.jsx"},'// highlight-next-line\nimport { Refine, Authenticated } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\nimport routerProvider from "@refinedev/react-router-v6";\n// highlight-next-line\nimport { BrowserRouter, Routes, Route, Outlet } from "react-router-dom";\n\n// highlight-next-line\nimport { authProvider } from "src/authProvider";\n\n// highlight-next-line\nimport { AuthPage } from "@refinedev/antd";\n\nimport { PostList, PostCreate } from "pages/posts";\nimport { CategoryList, CategoryShow } from "pages/categories";\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Refine\n        dataProvider={dataProvider}\n        routerProvider={routerProvider}\n        // highlight-next-line\n        authProvider={authProvider}\n        resources={[\n          {\n            name: "posts",\n            list: "/posts",\n            create: "/posts/create",\n          },\n          {\n            name: "categories",\n            list: "/categories",\n            show: "/categories/show/:id",\n          },\n        ]}\n      >\n        <Routes>\n          <Route\n            // highlight-start\n            element={\n              <Authenticated fallback={<Outlet />}>\n                <NavigateToResource resource="posts" />\n              </Authenticated>\n            }\n            // highlight-end\n          >\n            {/* highlight-next-line */}\n            <Route path="/login" element={<AuthPage type="login" />} />\n          </Route>\n          <Route\n            // highlight-start\n            element={\n              <Authenticated redirectOnFail="/login">\n                <Outlet />\n              </Authenticated>\n            }\n            // highlight-end\n          >\n            <Route path="posts">\n              <Route index element={<PostList />} />\n              <Route path="create" element={<PostCreate />} />\n            </Route>\n            <Route path="categories">\n              <Route index element={<CategoryList />} />\n              <Route path="show/:id" element={<CategoryShow />} />\n            </Route>\n          </Route>\n        </Routes>\n      </Refine>\n    </BrowserRouter>\n  );\n};\n')),(0,r.kt)("p",null,"Notice that we've used the ",(0,r.kt)("inlineCode",{parentName:"p"},"fallback")," property to render the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Outlet>")," component inside the wrapper ",(0,r.kt)("inlineCode",{parentName:"p"},"Route")," of the ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," page. This allows us to render the login page when the user is not authenticated and redirect the user to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts")," page when the user is authenticated."),(0,r.kt)("p",null,"We've also used the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Outlet>")," component inside the children of the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Authenticated>")," component in the wrapper ",(0,r.kt)("inlineCode",{parentName:"p"},"Route")," of the resource routes. This will allow us to render the resource routes only when the user is authenticated and redirect the user to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," page when the user is not authenticated."),(0,r.kt)("h3",{id:"usage-with-layouts"},"Usage with Layouts"),(0,r.kt)("p",null,"When using layouts in your application, you can use the same approach as the authentication example. We'll use the ",(0,r.kt)("a",{parentName:"p",href:"/docs/advanced-tutorials/custom-layout/#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"<ThemedLayoutV2>"))," component to wrap our routes and the ",(0,r.kt)("a",{parentName:"p",href:"https://reactrouter.com/en/main/components/outlet"},(0,r.kt)("inlineCode",{parentName:"a"},"<Outlet>"))," component from ",(0,r.kt)("inlineCode",{parentName:"p"},"react-router-dom")," to render our routes inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"<ThemedLayoutV2>")," component. This will allow us to define the common layout for our routes."),(0,r.kt)("p",null,"In the below example, we'll wrap our resource routes with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Layout")," component from ",(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/antd")," and render the routes inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Outlet>")," component."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"title=App.jsx",title:"App.jsx"},'import { Refine, Authenticated } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\nimport routerProvider from "@refinedev/react-router-v6";\nimport { BrowserRouter, Routes, Route, Outlet } from "react-router-dom";\n\nimport { authProvider } from "src/authProvider";\n\n// highlight-next-line\nimport { AuthPage, ThemedLayoutV2 } from "@refinedev/antd";\n\nimport { PostList, PostCreate } from "pages/posts";\nimport { CategoryList, CategoryShow } from "pages/categories";\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Refine\n        dataProvider={dataProvider}\n        routerProvider={routerProvider}\n        authProvider={authProvider}\n        resources={[\n          {\n            name: "posts",\n            list: "/posts",\n            create: "/posts/create",\n          },\n          {\n            name: "categories",\n            list: "/categories",\n            show: "/categories/show/:id",\n          },\n        ]}\n      >\n        <Routes>\n          <Route\n            element={\n              <Authenticated fallback={<Outlet />}>\n                <NavigateToResource resource="posts" />\n              </Authenticated>\n            }\n          >\n            <Route path="/login" element={<AuthPage type="login" />} />\n          </Route>\n          <Route\n            element={\n              <Authenticated redirectOnFail="/login">\n                {/* highlight-start */}\n                <ThemedLayoutV2>\n                  <Outlet />\n                </ThemedLayoutV2>\n                {/* highlight-end */}\n              </Authenticated>\n            }\n          >\n            <Route path="posts">\n              <Route index element={<PostList />} />\n              <Route path="create" element={<PostCreate />} />\n            </Route>\n            <Route path="categories">\n              <Route index element={<CategoryList />} />\n              <Route path="show/:id" element={<CategoryShow />} />\n            </Route>\n          </Route>\n        </Routes>\n      </Refine>\n    </BrowserRouter>\n  );\n};\n')),(0,r.kt)("p",null,"Notice that we've wrapped the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Outlet>")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"<ThemedLayoutV2>")," component. This way, we don't need to define the layout for each route and wrap the each route inside it with the ",(0,r.kt)("inlineCode",{parentName:"p"},"<ThemedLayoutV2>")," component."),(0,r.kt)("h3",{id:"usage-with-access-control-providers"},"Usage with Access Control providers"),(0,r.kt)("p",null,"If you want to protect your routes with ",(0,r.kt)("a",{parentName:"p",href:"/docs/authorization/access-control-provider"},"Access Control Provider"),", all you have to do is to wrap ",(0,r.kt)("inlineCode",{parentName:"p"},"Outlet")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"CanAccess")," component."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"CanAccess")," component will infer resource name and action based on the current route and handle the ",(0,r.kt)("strong",{parentName:"p"},"access control")," from your Access Control Provider for you."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"title=App.jsx",title:"App.jsx"},'// highlight-next-line\nimport { Refine, Authenticated, CanAccess } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\nimport routerProvider from "@refinedev/react-router-v6";\nimport { BrowserRouter, Routes, Route, Outlet } from "react-router-dom";\n\nimport { authProvider } from "src/authProvider";\n\nimport { AuthPage, ThemedLayoutV2 } from "@refinedev/antd";\n\nimport { PostList, PostCreate } from "pages/posts";\nimport { CategoryList, CategoryShow } from "pages/categories";\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Refine\n        dataProvider={dataProvider}\n        routerProvider={routerProvider}\n        authProvider={authProvider}\n        resources={[\n          {\n            name: "posts",\n            list: "/posts",\n            create: "/posts/create",\n          },\n          {\n            name: "categories",\n            list: "/categories",\n            show: "/categories/show/:id",\n          },\n        ]}\n      >\n        <Routes>\n          <Route\n            element={\n              <Authenticated fallback={<Outlet />}>\n                <NavigateToResource resource="posts" />\n              </Authenticated>\n            }\n          >\n            <Route path="/login" element={<AuthPage type="login" />} />\n          </Route>\n          <Route\n            element={\n              <Authenticated redirectOnFail="/login">\n                <ThemedLayoutV2>\n                  {/* highlight-start */}\n                  <CanAccess fallback={<div>Unauthorized!</div>}>\n                    <Outlet />\n                  </CanAccess>\n                  {/* highlight-end */}\n                </ThemedLayoutV2>\n              </Authenticated>\n            }\n          >\n            <Route path="posts">\n              <Route index element={<PostList />} />\n              <Route path="create" element={<PostCreate />} />\n            </Route>\n            <Route path="categories">\n              <Route index element={<CategoryList />} />\n              <Route path="show/:id" element={<CategoryShow />} />\n            </Route>\n          </Route>\n        </Routes>\n      </Refine>\n    </BrowserRouter>\n  );\n};\n')),(0,r.kt)("p",null,"If you don't want to wrap your whole application with ",(0,r.kt)("inlineCode",{parentName:"p"},"CanAccess"),", it's also possible to wrap certain routes individually."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"title=App.jsx",title:"App.jsx"},'<Routes>\n  <Route\n    element={\n      <Authenticated fallback={<Outlet />}>\n        <NavigateToResource resource="posts" />\n      </Authenticated>\n    }\n  >\n    <Route path="/login" element={<AuthPage type="login" />} />\n  </Route>\n  <Route\n    element={\n      <Authenticated redirectOnFail="/login">\n        <ThemedLayoutV2>\n          <Outlet />\n        </ThemedLayoutV2>\n      </Authenticated>\n    }\n  >\n    <Route path="posts">\n      <Route index element={<PostList />} />\n      <Route\n        path="create"\n        element={\n          // highlight-start\n          <CanAccess fallback={<div>Unauthorized!</div>}>\n            <PostCreate />\n          </CanAccess>\n          // highlight-end\n        }\n      />\n    </Route>\n    <Route path="categories">\n      <Route index element={<CategoryList />} />\n      <Route path="show/:id" element={<CategoryShow />} />\n    </Route>\n  </Route>\n</Routes>\n')),(0,r.kt)("h3",{id:"usage-with-an-error-page"},"Usage with an Error Page"),(0,r.kt)("p",null,"You may also want to render an error page when the user tries to access a route that doesn't exist. To do this, we'll define a ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," route that will render the error page when there's no other route that matches the current path."),(0,r.kt)("p",null,"We'll place this inside the authenticated routes so that the unauthorized users will be redirected to the login page when they try to access a route that doesn't exist."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"title=App.jsx",title:"App.jsx"},'import { Refine, Authenticated } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\nimport routerProvider from "@refinedev/react-router-v6";\nimport { BrowserRouter, Routes, Route, Outlet } from "react-router-dom";\n\nimport { authProvider } from "src/authProvider";\n\n// highlight-next-line\nimport { AuthPage, ThemedLayoutV2, ErrorComponent } from "@refinedev/antd";\n\nimport { PostList, PostCreate } from "pages/posts";\nimport { CategoryList, CategoryShow } from "pages/categories";\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Refine\n        dataProvider={dataProvider}\n        routerProvider={routerProvider}\n        authProvider={authProvider}\n        resources={[\n          {\n            name: "posts",\n            list: "/posts",\n            create: "/posts/create",\n          },\n          {\n            name: "categories",\n            list: "/categories",\n            show: "/categories/show/:id",\n          },\n        ]}\n      >\n        <Routes>\n          <Route\n            element={\n              <Authenticated fallback={<Outlet />}>\n                <NavigateToResource resource="posts" />\n              </Authenticated>\n            }\n          >\n            <Route path="/login" element={<AuthPage type="login" />} />\n          </Route>\n          <Route\n            element={\n              <Authenticated redirectOnFail="/login">\n                <ThemedLayoutV2>\n                  <Outlet />\n                </ThemedLayoutV2>\n              </Authenticated>\n            }\n          >\n            <Route path="posts">\n              <Route index element={<PostList />} />\n              <Route path="create" element={<PostCreate />} />\n            </Route>\n            <Route path="categories">\n              <Route index element={<CategoryList />} />\n              <Route path="show/:id" element={<CategoryShow />} />\n            </Route>\n            {/* highlight-next-line */}\n            <Route path="*" element={<ErrorComponent />} />\n          </Route>\n        </Routes>\n      </Refine>\n    </BrowserRouter>\n  );\n};\n')),(0,r.kt)("h3",{id:"usage-with-a-root-route"},"Usage with a Root Route"),(0,r.kt)("p",null,"You may notice that we didn't define an index route for our application yet. We can defina a root route that will redirect the user to the ",(0,r.kt)("inlineCode",{parentName:"p"},"posts")," resource when they visit the root of our application."),(0,r.kt)("p",null,"We can achieve this by using the ",(0,r.kt)("a",{parentName:"p",href:"#navigatetoresource"},(0,r.kt)("inlineCode",{parentName:"a"},"<NavigateToResource>"))," component. This component will redirect the user to the ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," page of the given resource."),(0,r.kt)("p",null,"We also want this route to be rendered only when the user is authenticated. We can achieve this by placing our ",(0,r.kt)("inlineCode",{parentName:"p"},"Route")," inside the authenticated routes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"title=App.jsx",title:"App.jsx"},'import { Refine, Authenticated } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\n// highlight-next-line\nimport routerProvider, { NavigateToResource } from "@refinedev/react-router-v6";\nimport { BrowserRouter, Routes, Route, Outlet } from "react-router-dom";\n\nimport { authProvider } from "src/authProvider";\n\nimport { AuthPage, ThemedLayoutV2, ErrorComponent } from "@refinedev/antd";\n\nimport { PostList, PostCreate } from "pages/posts";\nimport { CategoryList, CategoryShow } from "pages/categories";\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Refine\n        dataProvider={dataProvider}\n        routerProvider={routerProvider}\n        authProvider={authProvider}\n        resources={[\n          {\n            name: "posts",\n            list: "/posts",\n            create: "/posts/create",\n          },\n          {\n            name: "categories",\n            list: "/categories",\n            show: "/categories/show/:id",\n          },\n        ]}\n      >\n        <Routes>\n          <Route\n            element={\n              <Authenticated fallback={<Outlet />}>\n                <NavigateToResource resource="posts" />\n              </Authenticated>\n            }\n          >\n            <Route path="/login" element={<AuthPage type="login" />} />\n          </Route>\n          <Route\n            element={\n              <Authenticated redirectOnFail="/login">\n                <ThemedLayoutV2>\n                  <Outlet />\n                </ThemedLayoutV2>\n              </Authenticated>\n            }\n          >\n            {/* highlight-next-line */}\n            <Route index element={<NavigateToResource resource="posts" />} />\n            <Route path="posts">\n              <Route index element={<PostList />} />\n              <Route path="create" element={<PostCreate />} />\n            </Route>\n            <Route path="categories">\n              <Route index element={<CategoryList />} />\n              <Route path="show/:id" element={<CategoryShow />} />\n            </Route>\n            <Route path="*" element={<ErrorComponent />} />\n          </Route>\n        </Routes>\n      </Refine>\n    </BrowserRouter>\n  );\n};\n')),(0,r.kt)("p",null,"Your action definitions in the resources can contain additional parameters and nested routes. Passing these parameters when navigating to the pages are handled by the current available parameters and the ",(0,r.kt)("inlineCode",{parentName:"p"},"meta")," props of the related hooks and components."),(0,r.kt)("p",null,"Refine supports route parameters defined with ",(0,r.kt)("inlineCode",{parentName:"p"},":param")," syntax. You can use these parameters in your action definitions and create your routes accordingly. For example, if you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"posts")," resource and you want to create a route for the ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," action of a specific post, you can define the ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," action as ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts/show/:id")," and use the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," parameter in your component."),(0,r.kt)("h2",{id:"additional-components"},"Additional Components"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/react-router-v6")," package also includes some additional components that can be useful in some cases."),(0,r.kt)("h3",{id:"navigatetoresource"},"NavigateToResource"),(0,r.kt)("p",null,"A basic component that extends the ",(0,r.kt)("inlineCode",{parentName:"p"},"Navigate")," component from ",(0,r.kt)("strong",{parentName:"p"},"react-router-dom")," to navigate to a resource page. It is useful when you want to navigate to a resource page at the index route of your app."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'\nconst App = () => {\n    return (\n        <BrowserRouter>\n            <Refine\n                /* ... */\n                resources={[\n                    {\n                        name: "posts"\n                        list: "/posts",\n                    },\n                ]}\n            >\n                <Routes>\n                    {/* highlight-next-line */}\n                    <Route path="/" element={<NavigateToResource resource="posts" />} />\n                    <Route path="/posts" element={<PostList />} />\n                </Routes>\n            </Refine>\n        </BrowserRouter>\n    )\n}\n\n')),(0,r.kt)("h4",{id:"properties"},"Properties"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"resource")," (optional) - The name of the resource to navigate to. It will redirect to the first ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," route in the ",(0,r.kt)("inlineCode",{parentName:"p"},"resources")," array if not provided."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"meta")," (optional) - The meta object to use if the route has parameters in it. The parameters in the current location will also be used to compose the route but ",(0,r.kt)("inlineCode",{parentName:"p"},"meta")," will take precedence."),(0,r.kt)("h3",{id:"unsavedchangesnotifier"},"UnsavedChangesNotifier"),(0,r.kt)("p",null,"This component enables the ",(0,r.kt)("inlineCode",{parentName:"p"},"warnWhenUnsavedChanges")," feature of Refine. It will show a warning message when user tries to navigate away from the current page without saving the changes. Also checks for ",(0,r.kt)("inlineCode",{parentName:"p"},"beforeunload")," event to warn the user when they try to close the browser tab or window."),(0,r.kt)("p",null,"Place this component inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Refine>")," components children to enable this feature."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"const App = () => {\n  return (\n    <BrowserRouter>\n      <Refine\n        /* ... */\n        options={{\n          /* ... */\n          warnWhenUnsavedChanges: true,\n        }}\n      >\n        {/* ... */}\n        {/* highlight-next-line */}\n        <UnsavedChangesNotifier />\n      </Refine>\n    </BrowserRouter>\n  );\n};\n")),(0,r.kt)("h4",{id:"properties-1"},"Properties"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"translationKey")," (optional) - The translation key for the warning message. Default value is ",(0,r.kt)("inlineCode",{parentName:"p"},"warnWhenUnsavedChanges"),". Useful when you use an i18n provider."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"message")," (optional) - The warning message. Default value is ",(0,r.kt)("inlineCode",{parentName:"p"},"Are you sure you want to leave? You have unsaved changes.")," Useful when you don't use an i18n provider."),(0,r.kt)("h3",{id:"catchallnavigate"},"CatchAllNavigate"),(0,r.kt)("p",null,"It will redirect to the given path and keep the current location in ",(0,r.kt)("inlineCode",{parentName:"p"},"to")," query parameter to redirect back when needed. In some cases you may not want to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Authenticated>")," component's ",(0,r.kt)("inlineCode",{parentName:"p"},"redirectOnFail")," prop to redirect and have a catch-all route to redirect to the desired page. This is useful when handling the 404 pages with authentication."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'import { Refine } from "@refinedev/core";\nimport routerProvider, { CatchAllNavigate } from "@refinedev/react-router-v6";\nimport { AuthPage } from "@refinedev/antd";\n\nimport { BrowserRouter, Routes, Route } from "react-router-dom";\n\nimport authProvider from "src/authProvider";\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Refine\n        routerProvider={routerProvider}\n        authProvider={authProvider}\n        resources={[\n          {\n            name: "posts",\n            list: "/posts",\n          },\n        ]}\n      >\n        <Routes>\n          <Route path="/login" element={<AuthPage type="login" />} />\n          {/* ... */}\n          {/* highlight-next-line */}\n          <Route path="*" element={<CatchAllNavigate to="/login" />} />\n        </Routes>\n      </Refine>\n    </BrowserRouter>\n  );\n};\n')),(0,r.kt)("h4",{id:"properties-2"},"Properties"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"to")," (required) - The path to redirect to."),(0,r.kt)("h3",{id:"documenttitlehandler"},"DocumentTitleHandler"),(0,r.kt)("p",null,"This component will generate the document title for the current page.By default, it follows a set of predefined rules to generate titles based on the provided props. However, it also offers the flexibility to customize the title generation process by providing a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"handler")," function.\nThe default title generation rules are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"list : ",(0,r.kt)("inlineCode",{parentName:"li"},"Posts | Refine")),(0,r.kt)("li",{parentName:"ul"},"edit : ",(0,r.kt)("inlineCode",{parentName:"li"},"#{id} Edit Post | Refine")),(0,r.kt)("li",{parentName:"ul"},"show : ",(0,r.kt)("inlineCode",{parentName:"li"},"#{id} Show Post | Refine")),(0,r.kt)("li",{parentName:"ul"},"create : ",(0,r.kt)("inlineCode",{parentName:"li"},"Create new Post | Refine")),(0,r.kt)("li",{parentName:"ul"},"clone : ",(0,r.kt)("inlineCode",{parentName:"li"},"#{id} Clone Post | Refine")),(0,r.kt)("li",{parentName:"ul"},"default : ",(0,r.kt)("inlineCode",{parentName:"li"},"Refine"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"const App = () => {\n  return (\n    <BrowserRouter>\n      <Refine\n      /* ... */\n      >\n        {/* ... */}\n        {/* highlight-next-line */}\n        <DocumentTitleHandler />\n      </Refine>\n    </BrowserRouter>\n  );\n};\n")),(0,r.kt)("h4",{id:"properties-3"},"Properties"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"handler")," (optional) - The function that will get invoked in every location change. It will receive an object with the following properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pathname"),": The current URL pathname."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"resource"),': The resource being displayed (e.g., "posts").'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"action"),': The action being performed (e.g., "edit", "show", "create").'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"autoGeneratedTitle"),": The default auto-generated title based on the predefined rules."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"params"),": An object containing URL parameters, including the ",(0,r.kt)("inlineCode",{parentName:"li"},"id")," parameter if present.")),(0,r.kt)("p",null,"Inside the handler function, you can dynamically generate the document title based on the provided properties and any additional logic required. The function should return the generated title."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'const customTitleHandler = ({ resource, action, params }) => {\n  let title = "Custom default"; // Default title\n\n  if (resource && action) {\n    title = `${resource} ${action} ${params.id}`;\n  }\n\n  return title;\n};\n\n// Usage\n<DocumentTitleHandler handler={customTitleHandler} />;\n')),(0,r.kt)("h2",{id:"hooks"},"Hooks"),(0,r.kt)("h3",{id:"usedocumenttitle"},"useDocumentTitle"),(0,r.kt)("p",null,"This hook allows you to set the document title for the current page. It can be used in any component that is a child of the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Refine>")," component."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'import { useDocumentTitle } from "@refinedev/react-router-v6";\n\nconst PostList = () => {\n  // highlight-next-line\n  useDocumentTitle("Posts | Refine");\n\n  return <List>{/* ... */}</List>;\n};\n')),(0,r.kt)("p",null,"This hook can take an object as an argument with ",(0,r.kt)("inlineCode",{parentName:"p"},"i18nKey"),". This key will be used to translate the title using the i18n provider."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import { useDocumentTitle } from "@refinedev/react-router-v6";\n\nconst PostList = () => {\n  // highlight-next-line\n  useDocumentTitle({ i18nKey: "documentTitle.posts.list" });\n\n  return <List>{/* ... */}</List>;\n};\n')),(0,r.kt)("p",null,"This hook also returns a function that can be used to set the document title dynamically."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'import { useDocumentTitle } from "@refinedev/react-router-v6";\n\nconst PostList = () => {\n  const setTitle = useDocumentTitle();\n\n  useEffect(() => {\n    setTitle("Posts | Refine");\n  }, []);\n\n  return <List>{/* ... */}</List>;\n};\n')),(0,r.kt)("h2",{id:"faq"},"FAQ"),(0,r.kt)("h3",{id:"how-to-handle-optional-authentication-redirects-and-layouts-with-authentication"},"How to handle optional authentication, redirects and layouts with authentication?"),(0,r.kt)("p",null,"In the below example, you'll find different cases for route definitions, we've used ",(0,r.kt)("inlineCode",{parentName:"p"},"Authenticated")," component to handle authentication and redirects. You can always choose to use a different approach, Refine will allow you to handle the routes however you like."),(0,r.kt)("p",null,"For optional authentication, in our ",(0,r.kt)("inlineCode",{parentName:"p"},"authProvider")," implementation's ",(0,r.kt)("inlineCode",{parentName:"p"},"check")," method, we can pass ",(0,r.kt)("inlineCode",{parentName:"p"},"authentication: false")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"redirectTo: undefined")," to indicate that the current user is not authenticated but we don't want to redirect them to the login page. This is useful, when some pages in our app are public and don't require authentication and some pages are private and require authentication."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=authProvider.ts",title:"authProvider.ts"},'import { AuthProvider } from "@refinedev/core";\n\nexport const authProvider: AuthProvider = {\n  check: async () => {\n    const isAuthenticated = await yourMethodToCheckIfUserIsAuthenticated();\n\n    return {\n      // highlight-next-line\n      authentication: isAuthenticated,\n      // notice that we omit the `redirectTo` property\n    };\n  },\n  // ...\n};\n')),(0,r.kt)("p",null,"In our ",(0,r.kt)("inlineCode",{parentName:"p"},"App.tsx"),", while defining the routes, we'll leverage the ",(0,r.kt)("inlineCode",{parentName:"p"},"Outlet")," component from ",(0,r.kt)("inlineCode",{parentName:"p"},"react-router-dom")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Authenticated")," component from ",(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/core"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Initialization of ",(0,r.kt)("inlineCode",{parentName:"strong"},"<Refine>")," component")),(0,r.kt)("p",null,"Let's start with initializing our ",(0,r.kt)("inlineCode",{parentName:"p"},"<Refine>")," component with inside ",(0,r.kt)("inlineCode",{parentName:"p"},"<BrowserRouter>")," component. We'll pass our ",(0,r.kt)("inlineCode",{parentName:"p"},"dataProvider")," ",(0,r.kt)("inlineCode",{parentName:"p"},"routerProvider")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"authProvider")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Refine>")," component. We'll also pass our ",(0,r.kt)("inlineCode",{parentName:"p"},"resources")," and define our action paths for each resource in ",(0,r.kt)("inlineCode",{parentName:"p"},"<Refine>")," component."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=App.tsx",title:"App.tsx"},'import { Refine } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\nimport routerProvider from "@refinedev/react-router-v6";\n\nimport { BrowserRouter, Routes } from "react-router-dom";\n\nimport { authProvider } from "src/authProvider";\n\nexport const App = () => {\n  return (\n    <BrowserRouter>\n      <Refine\n        dataProvider={dataProvider}\n        routerProvider={routerProvider}\n        authProvider={authProvider}\n        resources={[\n          {\n            name: "posts",\n            list: "/posts",\n            create: "/posts/create",\n          },\n        ]}\n      >\n        {/* ... */}\n      </Refine>\n    </BrowserRouter>\n  );\n};\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Defining routes")),(0,r.kt)("p",null,"Then, let's start adding our routes. We'll start with the ",(0,r.kt)("inlineCode",{parentName:"p"},"LandingPage")," component at the ",(0,r.kt)("inlineCode",{parentName:"p"},"/")," path. This will be visible for both authenticated and unauthenticated users. We need to wrap our ",(0,r.kt)("inlineCode",{parentName:"p"},"Route")," elements with a ",(0,r.kt)("inlineCode",{parentName:"p"},"Routes")," component."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff",metastring:"title=App.tsx",title:"App.tsx"},'import { Refine } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\nimport routerProvider from "@refinedev/react-router-v6";\n\n+ import { BrowserRouter, Routes, Route } from "react-router-dom";\n\nimport { authProvider } from "src/authProvider";\n\n+ import { LandingPage } from "pages/landing";\n\nexport const App = () => {\n    return (\n        <BrowserRouter>\n            <Refine\n                dataProvider={dataProvider}\n                routerProvider={routerProvider}\n                authProvider={authProvider}\n                resources={[\n                    {\n                        name: "posts",\n                        list: "/posts",\n                        create: "/posts/create",\n                    },\n                ]}\n            >\n+               <Routes>\n+                   <Route index element={<LandingPage />} />\n+               </Routes>\n            </Refine>\n        </BrowserRouter>\n    )\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Defining authenticated routes")),(0,r.kt)("p",null,"Now, let's create our resource actions. They will be wrapped with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Layout")," component and only visible for authenticated users. We'll use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Authenticated")," component to handle authentication and redirects. We'll also use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Outlet")," component to properly wrap and handle the authenticated routes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff",metastring:"title=App.tsx",title:"App.tsx"},'+ import { Refine, Authenticated } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\nimport routerProvider from "@refinedev/react-router-v6";\n\n+ import { BrowserRouter, Routes, Route, Outlet } from "react-router-dom";\n\nimport { authProvider } from "src/authProvider";\n\nimport { LandingPage } from "pages/landing";\n+ import { PostList, PostCreate } from "pages/posts";\n\n+ import { Layout } from "components/layout";\n\nexport const App = () => {\n    return (\n        <BrowserRouter>\n            <Refine\n                dataProvider={dataProvider}\n                routerProvider={routerProvider}\n                authProvider={authProvider}\n                resources={[\n                    {\n                        name: "posts",\n                        list: "/posts",\n                        create: "/posts/create",\n                    },\n                ]}\n            >\n                <Routes>\n                    <Route index element={<LandingPage />} />\n+                   <Route\n+                       element={(\n+                           <Authenticated redirectOnFail="/login">\n+                               <Layout>\n+                                   <Outlet />\n+                               </Layout>\n+                           </Authenticated>\n+                       )}\n+                   >\n+                       <Route path="posts">\n+                           <Route index element={<PostList />} />\n+                           <Route path="create" element={<PostCreate />} />\n+                       </Route>\n+                   </Route>\n                </Routes>\n            </Refine>\n        </BrowserRouter>\n    )\n}\n')),(0,r.kt)("p",null,"Now, when we navigate to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts")," page we should either see the ",(0,r.kt)("inlineCode",{parentName:"p"},"PostList")," component or be redirected to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," page. If we're already authenticated, we should see the ",(0,r.kt)("inlineCode",{parentName:"p"},"PostList")," component."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Defining auth pages")),(0,r.kt)("p",null,"We can now add our ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"/register")," pages. We'll use the ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthPage")," component for both pages. We'll also navigate to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts")," page if the user is already authenticated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff",metastring:"title=App.tsx",title:"App.tsx"},'import { Refine, Authenticated } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\n+ import routerProvider, { NavigateToResource } from "@refinedev/react-router-v6";\n\nimport { BrowserRouter, Routes, Route, Outlet } from "react-router-dom";\n\nimport { authProvider } from "src/authProvider";\n\nimport { LandingPage } from "pages/landing";\nimport { PostList, PostCreate } from "pages/posts";\n+ import { AuthPage } from "pages/auth";\n\nimport { Layout } from "components/layout";\n\nexport const App = () => {\n    return (\n        <BrowserRouter>\n            <Refine\n                dataProvider={dataProvider}\n                routerProvider={routerProvider}\n                authProvider={authProvider}\n                resources={[\n                    {\n                        name: "posts",\n                        list: "/posts",\n                        create: "/posts/create",\n                    },\n                ]}\n            >\n                <Routes>\n                    <Route index element={<LandingPage />} />\n                    <Route\n                        element={(\n                            <Authenticated redirectOnFail="/login">\n                                <Layout>\n                                    <Outlet />\n                                </Layout>\n                            </Authenticated>\n                        )}\n                    >\n                        <Route path="posts">\n                            <Route index element={<PostList />} />\n                            <Route path="create" element={<PostCreate />} />\n                        </Route>\n                    </Route>\n+                   <Route\n+                       element={(\n+                           <Authenticated fallback={<Outlet />}>\n+                               <NavigateToResource resource="posts" />\n+                           </Authenticated>\n+                       )}\n+                   >\n+                       <Route path="/login" element={<AuthPage type="login" />} />\n+                       <Route path="/register" element={<AuthPage type="register" />} />\n+                   </Route>\n                </Routes>\n            </Refine>\n        </BrowserRouter>\n    )\n}\n')),(0,r.kt)("p",null,"Now, when we navigate to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"/register")," pages, we should either see the ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthPage")," component or be redirected to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts")," page. If we're already authenticated, we should be redirected to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts")," page."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Defining error page")),(0,r.kt)("p",null,"Finally, we'll add our ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorComponent")," component to show when user navigates to a non-existing page."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff",metastring:"title=App.tsx",title:"App.tsx"},'import { Refine, Authenticated } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\nimport routerProvider, { NavigateToResource } from "@refinedev/react-router-v6";\n\nimport { BrowserRouter, Routes, Route, Outlet } from "react-router-dom";\n\nimport { authProvider } from "src/authProvider";\n\n+ import { ErrorComponent } from "components/error";\nimport { LandingPage } from "pages/landing";\nimport { PostList, PostCreate } from "pages/posts";\nimport { AuthPage } from "pages/auth";\n\nimport { Layout } from "components/layout";\n\nexport const App = () => {\n    return (\n        <BrowserRouter>\n            <Refine\n                dataProvider={dataProvider}\n                routerProvider={routerProvider}\n                authProvider={authProvider}\n                resources={[\n                    {\n                        name: "posts",\n                        list: "/posts",\n                        create: "/posts/create",\n                    },\n                ]}\n            >\n                <Routes>\n                    <Route index element={<LandingPage />} />\n                    <Route\n                        element={(\n                            <Authenticated redirectOnFail="/login">\n                                <Layout>\n                                    <Outlet />\n                                </Layout>\n                            </Authenticated>\n                        )}\n                    >\n                        <Route path="posts">\n                            <Route index element={<PostList />} />\n                            <Route path="create" element={<PostCreate />} />\n                        </Route>\n                    </Route>\n                    <Route\n                        element={(\n                            <Authenticated fallback={<Outlet />}>\n                                <NavigateToResource resource="posts" />\n                            </Authenticated>\n                        )}\n                    >\n                        <Route path="/login" element={<AuthPage type="login" />} />\n                        <Route path="/register" element={<AuthPage type="register" />} />\n                    </Route>\n+                   <Route path="*" element={<ErrorComponent />} />\n                </Routes>\n            </Refine>\n        </BrowserRouter>\n    );\n};\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Result")),(0,r.kt)("p",null,"We've now added our ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthPage")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorComponent")," components to our app. We've also used the ",(0,r.kt)("inlineCode",{parentName:"p"},"Authenticated")," component to our routes to redirect the users to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," page if they're not authenticated. The index page is available for all users because we didn't wrap it with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Authenticated")," component."),(0,r.kt)("h3",{id:"handling-404s"},"Handling 404s"),(0,r.kt)("p",null,"In the earlier versions of Refine, if ",(0,r.kt)("inlineCode",{parentName:"p"},"authProvider")," was defined, we've redirected the users to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," route even with the 404s and 404 pages were only available to the authenticated users. Now, the routes are handled by the users, so you can handle the 404s however you like."),(0,r.kt)("h4",{id:"404-pages-for-both-authenticated-and-not-authenticated-users"},"404 Pages for both authenticated and not authenticated users"),(0,r.kt)("p",null,"Here's an example for rendering the ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorComponent")," for undefined routes for both authenticated and not authenticated users."),(0,r.kt)("p",null,"Let's start with defining the ",(0,r.kt)("inlineCode",{parentName:"p"},"Refine")," component."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=App.tsx",title:"App.tsx"},'import { Refine, Authenticated } from "@refinedev/core";\nimport routerProvider, { CatchAllNavigate } from "@refinedev/react-router-v6";\nimport dataProvider from "@refinedev/simple-rest";\n\nimport { BrowserRouter, Routes, Route, Outlet } from "react-router-dom";\n\nimport { authProvider } from "providers/authProvider";\n\nimport { ErrorPage } from "pages/error";\nimport { AuthPage } from "pages/auth";\nimport { PostList, CategoryList } from "pages/posts";\nimport { Layout } from "components/Layout";\n\nexport const App = () => {\n  return (\n    <BrowserRouter>\n      <Refine\n        routerProvider={routerProvider}\n        dataProvider={dataProvider("https://api.fake-rest.refine.dev")}\n        authProvider={authProvider}\n        resources={[\n          {\n            name: "posts",\n            list: "/posts",\n          },\n          {\n            name: "categories",\n            list: "/categories",\n          },\n        ]}\n      >\n        <Routes>{/* ... */}</Routes>\n      </Refine>\n    </BrowserRouter>\n  );\n};\n')),(0,r.kt)("p",null,"Now, we can add the routes with authentication control. We should place them inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"Routes")," component."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'<Route\n  element={\n    <Authenticated fallback={<CatchAllNavigate to="/login" />}>\n      <Layout>\n        <Outlet />\n      </Layout>\n    </Authenticated>\n  }\n>\n  <Route path="/posts" element={<PostList />} />\n  <Route path="/categories" element={<CategoryList />} />\n</Route>\n')),(0,r.kt)("p",null,"This will render the ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"/categories")," routes for authenticated users and apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"Layout")," when rendering. If the current visitor is not authenticated, it will redirect them to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," route."),(0,r.kt)("p",null,"Let's add the ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," route."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'<Route\n  element={\n    <Authenticated fallback={<Outlet />}>\n      <NavigateToResource />\n    </Authenticated>\n  }\n>\n  <Route path="/login" element={<AuthPage type="login" />} />\n</Route>\n')),(0,r.kt)("p",null,"This will render the ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," route for not authenticated users and redirect the authenticated users to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts")," route."),(0,r.kt)("p",null,"And finally, we will add a catch-all route (",(0,r.kt)("inlineCode",{parentName:"p"},"*"),") and render the ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorPage")," component."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'<Route\n  element={\n    <Authenticated fallback={<Outlet />}>\n      <Layout>\n        <Outlet />\n      </Layout>\n    </Authenticated>\n  }\n>\n  <Route path="*" element={<ErrorPage />} />\n</Route>\n')),(0,r.kt)("p",null,"We will render the ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorPage")," component for both authenticated and not authenticated users. Only authenticated users will be able to use the sider component we have in the layout."),(0,r.kt)("h4",{id:"404-pages-for-authenticated-users-only"},"404 Pages for authenticated users only"),(0,r.kt)("p",null,"The difference from the previous example is in the wrapper of the ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," route. Now we will redirect the unauthenticated users to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," route and show the ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorPage")," component for authenticated users only."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'<Route\n  element={\n    <Authenticated fallback={<CatchAllNavigate to="/login" />}>\n      <Layout>\n        <Outlet />\n      </Layout>\n    </Authenticated>\n  }\n>\n  <Route path="*" element={<ErrorPage />} />\n</Route>\n')),(0,r.kt)("p",null,"We can also omit the ",(0,r.kt)("inlineCode",{parentName:"p"},"fallback")," property and let the default redirect flow handle the unauthenticated users."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'<Route\n  element={\n    <Authenticated>\n      <Layout>\n        <Outlet />\n      </Layout>\n    </Authenticated>\n  }\n>\n  <Route path="*" element={<ErrorPage />} />\n</Route>\n')),(0,r.kt)("p",null,"This means we will look for the ",(0,r.kt)("inlineCode",{parentName:"p"},"redirectTo")," property in the ",(0,r.kt)("inlineCode",{parentName:"p"},"authProvider"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"check")," method. If it's defined, ",(0,r.kt)("inlineCode",{parentName:"p"},"<Authenticated>")," component will redirect the user to the ",(0,r.kt)("inlineCode",{parentName:"p"},"redirectTo")," route."))}f.isMDXComponent=!0}}]);